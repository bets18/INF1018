1.
A função dump percorre byte a byte uma região de memória, mostrando para cada endereço o conteúdo
em hexadecimal. O parâmetro p indica o endereço inicial e n indica quantos bytes devem ser mostrados

1.a
int i = 10000;
dump(&i, sizeof(i));

O sizeof(i) mostrou que um inteiro ocupa 4 bytes no compilador (pode variar de acordo com a arquitetura)
A ordem em que os bytes aparecem depende do sistema. Em PCs comuns é little-endian, ou seja, o byte menos significativo vem primeiro
Isso explica por que o número não aparece “inteiro”, mas quebrado em 4 bytes

1.b
long l = 10000;
dump(&l, sizeof(l));

No meu teste, o sizeof(long) foi 8 bytes (em sistemas 64 bits)
O valor é representado em little-endian também, ocupando 8 posições consecutivas de memória

1.c
short s = 10000;
dump(&s, sizeof(s));

O sizeof(short) foi 2 bytes
Novamente, a ordem segue o padrão little-endian

1.d
char c = 'a';   // ou c = 97;
dump(&c, sizeof(c));

Um char ocupa 1 byte apenas
O valor armazenado é o código ASCII do caractere. No caso de 'a', é 97 (0x61 em hexadecimal)

1.e
char p[] = "7509";
dump(p, sizeof(p));

Cada caractere é armazenado como um byte com seu código ASCII
O último byte é reservado para o caractere especial '\0' (fim da string)


2.a
O programa converte strings numéricas em inteiros:

string2num("1234")
A função percorre cada caractere da string
A cada passo: (*s - '0') converte o caractere para número (por exemplo, '3' - '0' = 3)
O valor é acumulado em a, que começa em 0 e vai sendo atualizado com a fórmula:
  a = a * 10 + dígito.

Passo a passo "1234":
s = '1' → a = 0*10 + 1 = 1
s = '2' → a = 1*10 + 2 = 12
s = '3' → a = 12*10 + 3 = 123
s = '4' → a = 123*10 + 4 = 1234

2.b 
Modificação da função para aceitar uma base como segundo parâmetro:

int string2num (char *s, int base) {
  int a = 0;
  for (; *s; s++) {
    a = a*base + (*s - '0');
  }
  return a;
}

teste:
string2num("777", 8)  → 511
string2num("777", 10) → 777


2.c 
Para aceitar letras como dígitos extras (a=10, b=11, …, z=35), a função precisa tratar:
- dígitos de '0' a '9' → 0 a 9
- letras de 'a' a 'z' → 10 a 35

Podemos usar isdigit() para verificar se é número ou não

Maior base suportada: 36 (10 dígitos + 26 letras)

teste:
string2num("1a", 16)   → 26
string2num("a09b", 16) → 41115
string2num("z09b", 36) → número válido em base 36
